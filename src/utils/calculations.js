/**
 * Utility functions for LP position calculations
 */

/**
 * Calculate the price range bounds for concentrated liquidity
 * @param {number} currentPrice - Current price of token0 in terms of token1
 * @param {number} rangePercent - Range percentage (e.g., 15 for ±15%)
 * @returns {{lower: number, upper: number}} Price range bounds
 */
export function calculatePriceRange(currentPrice, rangePercent) {
  const multiplier = rangePercent / 100;
  return {
    lower: currentPrice * (1 - multiplier),
    upper: currentPrice * (1 + multiplier)
  };
}

/**
 * Calculate liquidity concentration factor using Uniswap V3 sqrt price formula
 * Price range boost vs full-range position
 * @param {number} rangePercent - Range percentage (e.g., 15 for ±15%)
 * @returns {number} Concentration multiplier
 */
export function calculateConcentrationFactor(rangePercent) {
  // Uniswap V3 uses sqrt price for liquidity concentration
  // For a range [P_lower, P_upper], the concentration factor is:
  // 1 / (sqrt(P_upper) - sqrt(P_lower))

  // Normalize current price to 1
  const currentPrice = 1;
  const priceLower = currentPrice * (1 - rangePercent / 100);
  const priceUpper = currentPrice * (1 + rangePercent / 100);

  const sqrtPriceLower = Math.sqrt(priceLower);
  const sqrtPriceUpper = Math.sqrt(priceUpper);

  // Concentration factor
  // For ±15% range: ~6.65x (not 3.33x!)
  return 1 / (sqrtPriceUpper - sqrtPriceLower);
}

/**
 * Calculate tick from price for Uniswap V3/V4
 * @param {number} price - Price as token1/token0
 * @returns {number} Tick value
 */
export function priceToTick(price) {
  return Math.floor(Math.log(price) / Math.log(1.0001));
}

/**
 * Calculate price from tick for Uniswap V3/V4
 * @param {number} tick - Tick value
 * @returns {number} Price
 */
export function tickToPrice(tick) {
  return Math.pow(1.0001, tick);
}

/**
 * Calculate required capital based on target fees and APR
 * @param {number} targetAnnualFees - Target annual fee earnings in USD
 * @param {number} feeAPR - Expected fee APR (as decimal, e.g., 0.20 for 20%)
 * @param {number} concentrationFactor - Liquidity concentration multiplier
 * @returns {number} Required capital in USD
 */
export function calculateRequiredCapital(targetAnnualFees, feeAPR, concentrationFactor) {
  // Base capital for full-range position
  const baseCapital = targetAnnualFees / feeAPR;

  // Adjusted for concentrated liquidity
  // Concentrated liquidity earns more fees per dollar, so we need less capital
  return baseCapital / concentrationFactor;
}

/**
 * Calculate fee APR based on pool metrics
 * @param {number} dailyVolume - Average daily trading volume in USD
 * @param {number} feeTier - Fee tier in basis points (e.g., 3000 for 0.30%)
 * @param {number} totalLiquidity - Total pool liquidity in USD
 * @returns {number} Estimated fee APR as decimal
 */
export function calculateFeeAPR(dailyVolume, feeTier, totalLiquidity) {
  // Annual volume
  const annualVolume = dailyVolume * 365;

  // Fee tier as decimal (3000 basis points = 0.003 = 0.30%)
  const feeRate = feeTier / 1000000;

  // Annual fees generated by the pool
  const annualFees = annualVolume * feeRate;

  // APR = annual fees / total liquidity
  return annualFees / totalLiquidity;
}

/**
 * Calculate impermanent loss for a price change
 * @param {number} priceRatio - New price / initial price
 * @returns {number} Impermanent loss as percentage (negative value)
 */
export function calculateImpermanentLoss(priceRatio) {
  const sqrtRatio = Math.sqrt(priceRatio);
  const il = (2 * sqrtRatio) / (1 + priceRatio) - 1;
  return il * 100; // Convert to percentage
}

/**
 * Calculate token amounts for a given liquidity and price range
 * Uses concentrated liquidity formulas from Uniswap V3
 * @param {number} liquidity - Liquidity amount
 * @param {number} currentPrice - Current price
 * @param {number} lowerPrice - Lower price bound
 * @param {number} upperPrice - Upper price bound
 * @returns {{amount0: number, amount1: number}} Token amounts
 */
export function calculateTokenAmounts(liquidity, currentPrice, lowerPrice, upperPrice) {
  const sqrtPrice = Math.sqrt(currentPrice);
  const sqrtPriceLower = Math.sqrt(lowerPrice);
  const sqrtPriceUpper = Math.sqrt(upperPrice);

  let amount0 = 0;
  let amount1 = 0;

  if (currentPrice < lowerPrice) {
    // All liquidity in token0
    amount0 = liquidity * (1 / sqrtPriceLower - 1 / sqrtPriceUpper);
  } else if (currentPrice > upperPrice) {
    // All liquidity in token1
    amount1 = liquidity * (sqrtPriceUpper - sqrtPriceLower);
  } else {
    // Liquidity split between both tokens
    amount0 = liquidity * (1 / sqrtPrice - 1 / sqrtPriceUpper);
    amount1 = liquidity * (sqrtPrice - sqrtPriceLower);
  }

  return { amount0, amount1 };
}

/**
 * Calculate position value in USD
 * @param {number} amount0 - Amount of token0
 * @param {number} amount1 - Amount of token1
 * @param {number} price0USD - Price of token0 in USD
 * @param {number} price1USD - Price of token1 in USD
 * @returns {number} Total position value in USD
 */
export function calculatePositionValue(amount0, amount1, price0USD, price1USD) {
  return (amount0 * price0USD) + (amount1 * price1USD);
}

/**
 * Check if current price is within range
 * @param {number} currentPrice - Current price
 * @param {number} lowerPrice - Lower bound
 * @param {number} upperPrice - Upper bound
 * @returns {boolean} True if in range
 */
export function isPriceInRange(currentPrice, lowerPrice, upperPrice) {
  return currentPrice >= lowerPrice && currentPrice <= upperPrice;
}

/**
 * Calculate distance from price boundaries as percentage
 * @param {number} currentPrice - Current price
 * @param {number} lowerPrice - Lower bound
 * @param {number} upperPrice - Upper bound
 * @returns {{toLower: number, toUpper: number}} Distance percentages
 */
export function calculateDistanceToRangeBounds(currentPrice, lowerPrice, upperPrice) {
  const toLower = ((currentPrice - lowerPrice) / currentPrice) * 100;
  const toUpper = ((upperPrice - currentPrice) / currentPrice) * 100;

  return { toLower, toUpper };
}
